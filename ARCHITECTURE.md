# Architecture & Technical Manifesto

Этот документ является **Единым Источником Правды** (Single Source of Truth) касательно технических решений проекта. Любые отклонения должны быть обоснованы через ADR (Architecture Decision Record).

## 1. Философия и Принципы (Core Principles)

1. **KISS (Keep It Simple, Stupid) & YAGNI (You Aren't Gonna Need It):**
    * Мы решаем текущую задачу, а не гипотетическую проблему будущего.
    * Запрещена "преждевременная оптимизация".
    * Запрещено создание абстракций "на вырост".
2. **Minimum Magic:**
    * Мы используем магию SQLAlchemy, так как это стандарт.
    * **Запрещено:** создание собственных метаклассов, динамическая генерация типов, сложная рефлексия. Код должен быть "скучным" и понятным.
3. **Pythonic Way:**
    * Читаемость > Краткость.
    * Explicit is better than implicit (Явное лучше неявного).

## 2. Архитектурный стиль

Мы используем **Layered Architecture** с элементами **Pragmatic DDD**.

### Слои приложения

```plain text
┌──────────────────────────────────────────────────────────────────────────────────────────────┐
│                                     ВНЕШНИЕ ВЗАИМОДЕЙСТВИЯ                                     │
│                          (Telegram API, Пользователь, Системные события)                       │
└──────────────────────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌──────────────────────────────────────────────────────────────────────────────────────────────┐
│                               MIDDLEWARE LAYER (Cross-Cutting)                               │
│  ┌───────────────────┐  ┌───────────────────┐  ┌───────────────────┐  ┌───────────────────┐  │
│  │ LoggerMiddleware  │  │ RateLimitMiddle-  │  │   RoleMiddleware  │  │ UserActivityMiddle│  │
│  │ (логирование)     │  │ ware (защита от  │  │ (проверка прав)   │  │ ware (трекинг     │  │
│  └───────────────────┘  │ спама)           │  └───────────────────┘  │ активности)       │  │
│                         └───────────────────┘                         └───────────────────┘  │
│  • Обрабатывают запрос ДО попадания в хендлеры                                              │
│  • Получают зависимости через Dishka (scoped контейнер)                                     │
│  • Не содержат бизнес-логику (только триггеры и проверки)                                   │
└──────────────────────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌──────────────────────────────────────────────────────────────────────────────────────────────┐
│                            PRESENTATION LAYER (Thin Handlers)                                │
│  ┌────────────────────────────────────────────────────────────────────────────────────────┐  │
│  │  Handlers (aiogram)                                                                    │  │
│  │  • Парсинг входных данных (сообщения, команды, упоминания)                            │  │
│  │  • Валидация через Pydantic DTO (UserCreateDTO, AdjustUserPointsDTO)                  │  │
│  │  • Вызов методов Service Layer с передачей DTO                                         │  │
│  │  • Формирование ответа пользователю (без бизнес-логики!)                              │  │
│  └────────────────────────────────────────────────────────────────────────────────────────┘  │
│  ┌────────────────────────────────────────────────────────────────────────────────────────┐  │
│  │  Dialogs (aiogram-dialog)                                                              │  │
│  │  • Многошаговые сценарии (регистрация пользователя)                                   │  │
│  │  • Валидация на каждом шаге через DTO                                                  │  │
│  │  • Передача данных в Service Layer                                                     │  │
│  └────────────────────────────────────────────────────────────────────────────────────────┘  │
└──────────────────────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌──────────────────────────────────────────────────────────────────────────────────────────────┐
│                              SERVICE LAYER (Application Logic)                               │
│  ┌───────────────────┐  ┌───────────────────┐  ┌───────────────────┐                        │
│  │   UserService     │  │  PointsService    │  │   LevelService    │                        │
│  │  • register_      │  │  • adjust_user_   │  │  • get_next_level │                        │
│  │    student()      │  │    points()       │  │  • update_user_   │                        │
│  │  • set_user_role()│  │  • update_user_   │  │    level()        │                        │
│  │  • track_activity()│ │    level()        │  │                   │                        │
│  └───────────────────┘  └───────────────────┘  └───────────────────┘                        │
│  • Оркестрация процессов (координация репозиториев и моделей)                               │
│  • Управление транзакциями (коммит/откат)                                                   │
│  • Внедрение репозиториев через конструктор (получены из DI)                                │
│  • Вызов методов моделей (Domain Layer) для изменения состояния                             │
└──────────────────────────────────────────────────────────────────────────────────────────────┘
                                    │
        ┌───────────────────────────┼───────────────────────────┐
        │                           │                           │
        ▼                           ▼                           ▼
┌─────────────────────┐   ┌─────────────────────┐   ┌─────────────────────┐
│   DOMAIN LAYER      │   │ INFRASTRUCTURE LAYER│   │   VALUE OBJECTS     │
│  (Rich ORM Models)  │   │   (Repositories)    │   │                     │
│  ┌───────────────┐  │   │  ┌───────────────┐  │   │  ┌───────────────┐  │
│  │     User      │◄─┼───┼──┤ UserRepository│  │   │  │    Points     │  │
│  │  • add_role() │  │   │  │ • create_user │  │   │  │ • adjust()    │  │
│  │  • remove_role│  │   │  │ • has_role()  │  │   │  │ • is_positive()│ │
│  │  • set_initial│  │   │  │ • get_by_tg_id│  │   │  │ • compare_to_ │  │
│  │    _levels()  │  │   │  └───────────────┘  │   │  │   threshold() │  │
│  └───────────────┘  │   │  ┌───────────────┐  │   │  └───────────────┘  │
│  ┌───────────────┐  │   │  │LevelRepository│  │   │  • Иммутабельны    │
│  │    Level      │◄─┼───┼──┤ • get_all()   │  │   │  • Семантические   │
│  │  • is_reach-  │  │   │  │ • get_initial │  │   │    методы         │
│  │    able()     │  │   │  └───────────────┘  │   │  • Валидация при   │
│  └───────────────┘  │   │                     │   │    создании       │
│                     │   │  • Сессия БД        │   └─────────────────────┘
│  • Бизнес-логика    │   │    внедряется в     │
│    инкапсулирована  │   │    методы           │
│  • Методы изменяют  │   │  • Stateless        │
│    своё состояние   │   │    (без хранения    │
│  • Не знают о сессии│   │    сессии внутри)   │
└─────────────────────┘   └─────────────────────┘
        │                           │
        └───────────┬───────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────────────────────────────────────────────┐
│                                      DATABASE (SQLite)                                                                                       │
│  ┌───────────────┐  ┌───────────────┐  ┌───────────────┐  ┌───────────────┐                  │
│  │     users     │  │    levels     │  │     roles     │  │  user_levels  │                  │
│  │  (User ORM)   │  │  (Level ORM)  │  │  (Role ORM)   │  │ (UserLevel ORM)│                 │
│  └───────────────┘  └───────────────┘  └───────────────┘  └───────────────┘                  │
└─────────────────────────────────────────────────────────────────────────────────────────────┘
```

#### Распределение ответственности по слоям

| Слой | Ответственность | Зависимости | Получает через DI |
| :--- | :--- | :--- | :--- |
| **Middleware** | Cross-cutting concerns | Dishka Container | AsyncSession, UserRepository |
| **Presentation** | Парсинг, валидация, ответ | DTO, Service Layer | UserService, AsyncSession |
| **Service** | Оркестрация, транзакции | Репозитории, Модели | UserRepository, LevelRepository |
| **Domain** | Бизнес-логика данных | Нет (чистые методы) | — |
| **Infrastructure** | Доступ к данным | SQLAlchemy, Сессия | Сессия передаётся в методы |
| **Value Objects** | Семантика данных | Pydantic | — |

#### Правила передачи данных между слоями

```python
# 1. PRESENTATION → SERVICE: DTO (валидированные данные)
handler_data = AdjustUserPointsDTO(
    recipient_id=123,
    giver_id=456,
    points=Points(value=100, point_type=LevelTypeEnum.ACADEMIC),
    reason="За решение задачи"
)
service.adjust_user_points(handler_data)  # ← Передаём целиком DTO

# 2. SERVICE → DOMAIN: Вызов методов моделей
user.add_points(100)  # ← Инкапсулированная логика в модели
user.set_initial_levels(levels)  # ← Модель сама управляет связями

# 3. SERVICE → INFRASTRUCTURE: Сессия + параметры
repo.get_by_telegram_id(db=session, tg_id=123)  # ← Сессия передаётся явно

# 4. ВСЕ СЛОИ → DTO: Для возврата данных
return UserReadDTO(
    id=user.id,
    first_name=user.first_name,
    academic_points=Points(value=user.academic_points, ...)
)
```

#### DI Container (Dishka) — "Клей" архитектуры

```python
# di/containers.py
DatabaseProvider()   # → Engine (APP scope)
SessionProvider()    # → AsyncSession (REQUEST scope — новая на каждый update)
RepositoryProvider() # → UserRepository, LevelRepository (APP scope, stateless)
ServiceProvider()    # → UserService (REQUEST scope, получает репозитории в конструкторе)
```

##### Как это работает

1. При получении update от Telegram создаётся новая сессия (REQUEST scope)
2. Middleware получают сессию через async with container() as c: db = await c.get(AsyncSession)
3. Handler получает сервис через FromDishka[UserService] (автоинжект)
4. Сервис получает репозитории в конструкторе при создании (один раз на запрос)
5. После обработки сессия автоматически закрывается, транзакция коммитится или откатывается

#### Критически важные правила

❌ Запрещено: Прямой доступ к БД из Presentation Layer

```python
# ПЛОХО
@handler
async def bad_handler(message: Message, db: AsyncSession):
    user = await db.execute(select(User).where(...))  # ← Нарушение слоёв!
```

✅ Разрешено: Только через сервисы и репозитории

```python

# ХОРОШО
@handler
async def good_handler(message: Message, user_service: FromDishka[UserService]):
    user = await user_service.get_user_by_telegram_id(message.from_user.id)
```

Domain Layer не знает о сессии:

```python

В модели User
def add_role(self, role: Role) -> None:  # ← Нет параметра db!
    new_link = UserRole(user_id=self.id, role_id=role.id)
    self.roles.append(new_link)  # ← ORM сам отслеживает изменения
```

DTO иммутабельны:

```python
points = Points(value=100, point_type=LevelTypeEnum.ACADEMIC)
points.value = 200  # ← Вызовет ошибку! Используем points.adjust(100)
```

#### Решение архитектурных проблем

| Проблема | Решение в архитектуре |
| :--- | :--- |
| **Спагетти-код в хендлерах** | Thin Handlers + Service Layer |
| **Дублирование запросов к БД** | Репозитории + selectinload |
| **Ошибки MissingGreenlet** | Scoped сессии через Dishka |
| **Сложность тестирования** | Изолированные слои + иммутабельные DTO |
| **Нарушение целостности данных** | Бизнес-логика в моделях (Rich Models) |
| **Утечки памяти** | Автоматическое закрытие сессий в DI |

### Паттерны

* **DI / IoC:** Зависимости внедряются явно (в конструкторы или через DI-контейнер). Глобальные переменные сводим к минимуму.
* **Composition over Inheritance:** Предпочитаем компоновку наследованию.
* **Law of Demeter (Relaxed):** Избегаем длинных цепочек вызовов (`a.b.c.d()`). *Исключения:* Построение запросов и методы моделей SQLAlchemy, иммутабельные пайплайны валидации, DTO, итерация коллекций, паттерн Builder
* **GoF (Gang of Four):** Используем стандартные паттерны, где это упрощает понимание (например, Strategy для разных способов начисления баллов, Factory для создания сложных объектов). ***Warning:** Не натягиваем паттерны на глобус. Если задачу можно решить простым if/else или функцией высшего порядка — выбираем простое решение.*
* **Composition Root:** Вся сборка графа зависимостей (инициализация сервисов, репозиториев, бота) происходит в одной точке входа (обычно main.py или отдельный контейнер di.py).

### Профилирование и Оптимизация

* Правило: "Преждевременная оптимизация — корень всех зол".
* Оптимизация производится только на основе данных профайлинга.
* Алгоритм: Сначала пишем читаемый код -> Если тормозит, запускаем профайлер -> Оптимизируем узкое место.
* Любые PR с пометкой "optimization" должны содержать скриншот или лог до и после профайлинга, доказывающий прирост производительности.

## 3. Стек и Инструменты

* **База данных:** SQLite (Dev/Prod MVP).
* **ORM:** SQLAlchemy 2.0 (Async).
* **Линтер/Форматер:** `ruff` (конфигурация в `pyproject.toml`).
* **Инфраструктура:** Docker & Docker Compose, Github Action, Makefile, pre-commit.
* **DI-контейнер:** Dishka.
* **Телеграм-бот:** Aiogram, Aiogram-dialog.
* **Админ-панель:** SQLAdmin, FastAPI.
* **Type checker:** ty.
* **Менеджер пакетов:** uv.
* **Валидация/DTO:** Pydantic V2.

## 4. Ограничения реализации

* **Type Hints:** Строго обязательны для всех сигнатур функций и публичных атрибутов. Соблюдаются в рамках папки src.
* **Docstrings:** Google Style. Обязательны для модулей, классов и публичных методов слоев Service и Repository.
* **SOLID/GRASP:** Применяем при проектировании и рефакторинге, но без фанатизма (см. пункт KISS).
* **SQLite Specifics:**
  * Foreign Keys: Обязательно включать PRAGMA foreign_keys=ON при инициализации соединения (в main или DI).
  * Enums: Используем только строковое хранение (native_enum=False в SQLAlchemy).
