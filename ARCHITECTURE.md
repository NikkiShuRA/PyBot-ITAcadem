# Architecture & Technical Manifesto

Этот документ является **Единым Источником Правды** (Single Source of Truth) касательно технических решений проекта. Любые отклонения должны быть обоснованы через ADR (Architecture Decision Record).

## 1. Философия и Принципы (Core Principles)

1. **KISS (Keep It Simple, Stupid) & YAGNI (You Aren't Gonna Need It):**
    * Мы решаем текущую задачу, а не гипотетическую проблему будущего.
    * Запрещена "преждевременная оптимизация".
    * Запрещено создание абстракций "на вырост".
2. **Minimum Magic:**
    * Мы используем магию SQLAlchemy, так как это стандарт.
    * **Запрещено:** создание собственных метаклассов, динамическая генерация типов, сложная рефлексия. Код должен быть "скучным" и понятным.
3. **Pythonic Way:**
    * Читаемость > Краткость.
    * Explicit is better than implicit (Явное лучше неявного).

## 2. Архитектурный стиль

Мы используем **Layered Architecture** с элементами **Pragmatic DDD**.

### Слои приложения

1. **Presentation Layer (Bot Handlers / API):**
    * Максимально тонкие.
    * Отвечают только за парсинг входных данных и форматирование ответа.
    * **Никакой бизнес-логики.**
2. **Service Layer (Application Logic):**
    * Оркестрация процессов.
    * Управление транзакциями (Unit of Work).
3. **Domain Layer (Rich Model):**
    * Бизнес-логика инкапсулирована в методах моделей (ORM).
    * Пример: `user.add_points(amount)` вместо `user.balance += amount` в сервисе.
4. **Infrastructure Layer (Repository / DB):**
    * Чистый доступ к данным.

### Паттерны

* **DI / IoC:** Зависимости внедряются явно (в конструкторы или через DI-контейнер). Глобальные переменные сводим к минимуму.
* **Composition over Inheritance:** Предпочитаем компоновку наследованию.
* **Law of Demeter (Relaxed):** Избегаем длинных цепочек вызовов (`a.b.c.d()`). *Исключения:* Построение запросов и методы моделей SQLAlchemy, иммутабельные пайплайны валидации, DTO, итерация коллекций, паттерн Builder
* **GoF (Gang of Four):** Используем стандартные паттерны, где это упрощает понимание (например, Strategy для разных способов начисления баллов, Factory для создания сложных объектов). ***Warning:** Не натягиваем паттерны на глобус. Если задачу можно решить простым if/else или функцией высшего порядка — выбираем простое решение.*
* **Composition Root:** Вся сборка графа зависимостей (инициализация сервисов, репозиториев, бота) происходит в одной точке входа (обычно main.py или отдельный контейнер di.py).

### Профилирование и Оптимизация

* Правило: "Преждевременная оптимизация — корень всех зол".
* Оптимизация производится только на основе данных профайлинга.
* Алгоритм: Сначала пишем читаемый код -> Если тормозит, запускаем профайлер -> Оптимизируем узкое место.
* Любые PR с пометкой "optimization" должны содержать скриншот или лог до и после профайлинга, доказывающий прирост производительности.

## 3. Стек и Инструменты

* **База данных:** SQLite (Dev/Prod MVP).
* **ORM:** SQLAlchemy 2.0 (Async).
* **Линтер/Форматер:** `ruff` (конфигурация в `pyproject.toml`).
* **Инфраструктура:** Docker & Docker Compose, Github Action, Makefile, pre-commit.
* **DI-контейнер:** Dishka.
* **Телеграм-бот:** Aiogram, Aiogram-dialog.
* **Админ-панель:** SQLAdmin, FastAPI.
* **Type checker:** ty.
* **Менеджер пакетов:** uv.
* **Валидация/DTO:** Pydantic V2.

## 4. Ограничения реализации

* **Type Hints:** Строго обязательны для всех сигнатур функций и публичных атрибутов. Соблюдаются в рамках папки src.
* **Docstrings:** Google Style. Обязательны для модулей, классов и публичных методов слоев Service и Repository.
* **SOLID/GRASP:** Применяем при проектировании и рефакторинге, но без фанатизма (см. пункт KISS).
* **SQLite Specifics:**
  * Foreign Keys: Обязательно включать PRAGMA foreign_keys=ON при инициализации соединения (в main или DI).
  * Enums: Используем только строковое хранение (native_enum=False в SQLAlchemy).
