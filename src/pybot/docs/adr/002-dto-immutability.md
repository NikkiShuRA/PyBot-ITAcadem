# ADR 002: Введение иммутабельности для DTO

## Дата: 20-12-2025

## Статус: Accepted

## Контекст

Проект переходит к более зрелой архитектуре с четким разделением слоев (Представление, Бизнес-логика, Данные), использованием DTO и доменных сущностей, репозиториев и EventBus. DTO используются как контракты для передачи данных между слоями и для валидации с помощью Pydantic V2.

Текущая конфигурация Pydantic DTO запрещает добавление новых атрибутов (`extra="forbid"`), что обеспечивает иммутабельность контракта. Однако, сами значения атрибутов остаются мутабельными.

В контексте асинхронного программирования (asyncio), где корутины могут конкурентно получать доступ к одним и тем же объектам DTO, мутабельность может привести к трудновоспроизводимым ошибкам. Разная последовательность операций с побочными эффектами (изменения DTO "по месту") может давать непредсказуемые результаты, что крайне затрудняет отладку. Возникает риск неявных изменений данных между передачами DTO от одного компонента к другому.

Цель этого решения — повысить предсказуемость поведения системы, улучшить безопасность передачи данных и значительно упростить тестирование, исключив целый класс потенциальных ошибок.

## Решение

Принято решение сделать все DTO, используемые в проекте, полностью иммутабельными. Это будет реализовано путем установки параметра `frozen=True` в `model_config` для родительского класса Pydantic V2 моделей, которые служат DTO.

Пример:
```python
from pydantic import BaseModel, ConfigDict


class BaseDTO(BaseModel):
    model_config = ConfigDict(from_attributes=True, extra="forbid", "frozen": True,  # Делает DTO полностью иммутабельным)
```

Для "изменения" DTO будет использоваться метод `model_copy` с параметром `update`, который создает новую иммутабельную копию DTO с заданными изменениями, оставляя исходный объект неизменным.

Пример создания новой копии:
```python
original_dto = MyImmutableDTO(id=1, name="Alice")
updated_dto = original_dto.model_copy(update={"name": "Bob"})
```

## Альтернативы

*   **Оставить DTO мутабельными (текущее состояние):**
    *   **Плюсы:** Не требует изменений в существующем коде, если есть мутации "по месту".
    *   **Минусы:** Сохраняет риски возникновения "race conditions" и непредсказуемых побочных эффектов в асинхронной среде. Усложняет тестирование из-за необходимости отслеживать изменения состояния и потенциальной зависимости тестов друг от друга. Снижает предсказуемость поведения DTO как контракта.

*   **Использовать `dataclasses` с `frozen=True`:**
    *   **Плюсы:** Обеспечивает иммутабельность.
    *   **Минусы:** `dataclasses` предоставляют меньше встроенных функций по сравнению с Pydantic V2 (валидация, сериализация, кастомизация), которые уже активно используются в проекте для DTO. Переход на `dataclasses` только для иммутабельности был бы неэффективным.

*   **Ручная реализация иммутабельности/копирования:**
    *   **Плюсы:** Полный контроль.
    *   **Минусы:** Избыточная работа и высокий риск ошибок по сравнению с использованием встроенных механизмов Pydantic V2 (`frozen=True`, `model_copy`).

## Последствия

*   **Потокобезопасность и предсказуемость (Плюс):** Полностью исключается класс ошибок, связанных с конкурентным изменением DTO. Гарантируется, что DTO, полученный функцией или методом, останется неизменным на протяжении всего его жизненного цикла в этой функции, что устраняет "мерзкие" трудновоспроизводимые баги. DTO становится надежным "слепком" данных.
*   **Улучшение безопасности и предсказуемости (Плюс):** Если целью вызова является получение данных, то гарантируется, что данные не будут неожиданно изменены. Если же требуется изменение, это всегда будет явной операцией создания нового DTO, что делает намерение кода очевидным и уменьшает побочные эффекты.
*   **Упрощение тестирования (Плюс):** Значительно облегчает юнит-тестирование. Функции, принимающие и возвращающие иммутабельные DTO, становятся "чистыми функциями" с минимальными сайд-эффектами. Это повышает уверенность, что один тест не повлияет на другой, и сокращает усилия по созданию и очистке тестового окружения.
*   **Упрощение сериализации/кэширования (Плюс):** Иммутабельные объекты легче кэшировать, их хэши остаются стабильными. Упрощается логика сериализации, так как не нужно беспокоиться о текущем состоянии или циклических ссылках, которые могут быть проблемой для мутабельных объектов.
*   **Накладные расходы на создание объектов (Минус, незначительный):** Каждое "изменение" DTO теперь требует создания нового объекта. Для большинства DTO в проекте это не будет узким местом по производительности, так как DTO обычно не используются в высокопроизводительных циклах обработки данных, требующих мутации на месте.
*   **Изменение стиля кодирования (Минус, адаптация):** Разработчикам потребуется привыкнуть к использованию `model_copy(update={...})` вместо прямого присваивания атрибутов. Pydantic будет выдавать ошибки, если попытаться изменить атрибут `frozen` модели, что поможет в адаптации.

## Ссылки

*   [Pydantic V2 docs on `frozen` models](https://docs.pydantic.dev/latest/api/config/#pydantic.config.ConfigDict.frozen)
*   [Pydantic V2 docs on `model_copy`](https://docs.pydantic.dev/latest/api/base_model/#pydantic.main.BaseModel.model_copy)
*   [ADR 001: Введение DTO и доменных сущностей для разделения слоёв](#ADR-001:-Введение-DTO-и-доменных-сущностей-для-разделения-слоёв) (для контекста)
