# ADR 0005: Переход к Rich ORM Models и отказ от чистых Domain Entities

## Дата: 26-10-2023

## Статус: Accepted

## Контекст

В ходе разработки проекта, следуя принципам "Академического DDD" и Clean Architecture, мы изначально разделили слой данных и слой бизнес-логики. Это привело к следующей цепочке передачи данных:
`DB Row` <-> `SQLAlchemy ORM Model` <-> `Pure Python Domain Entity` <-> `DTO`.

Мы столкнулись со следующими проблемами:

1. **Избыточный маппинг:** Необходимость писать конвертеры между ORM-моделями и Доменными сущностями, которые часто дублируют поля 1-в-1.
2. **Сложность поддержки:** Добавление одного поля в базу требует изменений в 3-4 файлах и написания новых мапперов.
3. **Анемичная модель:** Бизнес-логика (например, проверка баланса баллов, логика повышения уровня) "размазывалась" по Сервисам (Service Layer) или даже Хендлерам, превращая модели в простые структуры данных (data containers).
4. **Отсутствие выгоды от абстракции:** В рамках Python и асинхронного стека (SQLAlchemy + Pydantic) полная изоляция от ORM не принесла ожидаемой гибкости, но увеличила объем кода (boilerplate).

Нам необходимо упростить архитектуру, сохранив при этом инкапсуляцию бизнес-правил и возможность тестирования.

## Решение

Принято решение отказаться от выделенного слоя "Чистых Доменных Сущностей" (Pure Domain Entities) и использовать паттерн **Rich ORM Model (Богатая Модель Данных)** в рамках подхода **Pragmatic DDD**.

Теперь SQLAlchemy-модели (`src/database/models`) выступают в роли Доменных Сущностей (Entities/Aggregates).

### Детали реализации

1. **Объединение:** Классы ORM теперь содержат не только определение полей БД, но и методы бизнес-логики, касающиеся изменения состояния этой сущности.
2. **Инкапсуляция:** Логика валидации и изменения внутреннего состояния (например, `add_points`, `change_status`) переносится из Сервисов внутрь методов Модели.
3. **Границы ответственности:**
    * **Rich Model:** Знает "КАК" меняются данные (инварианты, проверки). Не знает о сессии БД (`AsyncSession`).
    * **Application Service:** Знает "КОГДА" вызывать методы модели, управляет транзакциями (Unit of Work) и оркестрирует взаимодействие между репозиториями.
    * **Domain Service:** Используется только для логики, затрагивающей несколько агрегатов одновременно, или сложных вычислений, не требующих хранения состояния.
4. **DTO:** Используются исключительно на границах системы (входные данные от пользователя и ответ API/Bot), мапятся напрямую из ORM моделей.

```python
# Было (Anemic Model + Service Logic):
# Service:
# user.points += 10
# if user.points < 0: user.points = 0

# Стало (Rich Model):
class User(Base):
    # ... поля ...

    def add_points(self, amount: int, reason: str = None) -> None:
        """Метод инкапсулирует логику изменения и инварианты."""
        self.academic_points += amount
        if self.academic_points < 0:
            self.academic_points = 0
        # Модель сама следит за целостностью своего состояния
```

## Альтернативы

* **[Вариант 1]: Классический DDD (Clean Architecture с разделением Model/Entity)**
  * *Плюсы:* Полная независимость бизнес-логики от фреймворка БД (SQLAlchemy). Возможность заменить БД без переписывания домена.
  * *Минусы:* Огромное количество шаблонного кода (boilerplate) для маппинга. Повышенная когнитивная нагрузка. Снижение производительности из-за постоянного перекладывания данных. "Over-engineering" для текущего масштаба проекта. Сомнительность замены SQLAlchemy на другую ORM в python-экосистеме, без необходимости переписывать логику работы с базой данных.

* **[Вариант 2]: Transaction Script (Логика в сервисах, "глупые" модели)**
  * *Плюсы:* Очень быстро писать простой код "в лоб". Понятно новичкам.
  * *Минусы:* Дублирование логики (одни и те же проверки в разных хендлерах). Нарушение DRY. Риск привести данные в несогласованное состояние (например, отрицательные баллы), если забыть проверку в одном месте.

## Последствия

### Положительные

* [+] **Сокращение кодовой базы:** Удалены дублирующие классы и мапперы.
* [+] **High Cohesion (Высокая сцепленность):** Логика изменения данных находится там же, где и сами данные.
* [+] **Упрощение рефакторинга:** Изменение схемы БД сразу отражается на бизнес-объекте.
* [+] **ACID контроль:** Транзакции управляются явно в Application Services, а не размазаны по доменным объектам.

### Отрицательные

* [-] **Coupling (Связность):** Бизнес-логика теперь жестко привязана к библиотеке SQLAlchemy. Замена ORM потребует переписывания бизнес-классов (считаем риск приемлемым, так как SQLAlchemy — стандарт де-факто).
* [-] **Смешанная ответственность:** В одном классе находятся и настройки маппинга БД (`Column`, `ForeignKey`), и методы логики. Решается аккуратной структурой кода внутри класса.

## Ссылки

* [Martin Fowler: Anemic Domain Model](https://martinfowler.com/bliki/AnemicDomainModel.html)
* [Architecture Patterns with Python (Harry Percival & Bob Gregory)](https://www.cosmicpython.com/)
