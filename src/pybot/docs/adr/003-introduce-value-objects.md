# ADR 003: Введение паттерна Value Object и реализация Points

## Дата: 23-12-2025

## Статус: Accepted

## Контекст

В текущей архитектуре проекта для представления количественных характеристик (например, учебных баллов, очков опыта) используются примитивные типы данных (преимущественно `int`).

Использование примитивов ("Primitive Obsession") влечет за собой ряд проблем:

1. **Размытая логика валидации:** Проверки на допустимые диапазоны значений (например, защита от переполнения или отрицательных чисел там, где они недопустимы) дублируются в различных сервисах или отсутствуют вовсе.
2. **Низкая семантика:** Код вида `if user.points > 0` не раскрывает бизнес-смысла проверки.
3. **Нарушение инкапсуляции:** Логика изменения состояния (начисление/списание) вынесена наружу, в сервисный слой, вместо того чтобы находиться рядом с данными.
4. **Мутабельность:** Как и в случае с DTO (см. ADR 002), работа с изменяемыми данными усложняет отслеживание потока данных и тестирование.

В рамках развития доменной модели требуется выделить логику работы с очками геймификации в отдельную абстракцию, гарантирующую целостность данных и улучшающую читаемость кода.

## Решение

Принято решение внедрить паттерн **Value Object (Объект-значение)** и реализовать класс `Points` для управления очками геймификации.

В качестве базовой технологии для реализации Value Objects (VO) выбран **Pydantic V2**. Это обеспечивает единообразие с DTO и предоставляет мощные механизмы валидации «из коробки».

Была произведена замена полей для очков геймификации и их типов в DTO и доменных сущностях, также логика начисления баллов была адаптирована под работу с Value object.

### Детали реализации

1. **Базовый класс:** Создается абстракция `BaseValueModel` (наследник `BaseModel` Pydantic) с конфигурацией `frozen=True` для обеспечения технической иммутабельности.
2. **Иммутабельность:** Объекты `Points` неизменяемы. Любая операция, подразумевающая изменение состояния (например, начисление баллов), возвращает **новый** экземпляр объекта.
3. **Инкапсуляция логики:** Вся логика валидации (границы значений `int`) и математических операций (`adjust`) скрыта внутри класса.
4. **Семантические методы:** Вместо прямых сравнений значений вводятся методы, описывающие бизнес-смысл операции (например, `is_positive`, `is_negative_delta`).

Пример реализации:

```python:disable-run
from typing import Annotated
from enum import Enum
from pydantic import BaseModel, Field, ConfigDict

class BaseValueModel(BaseModel):
    model_config = ConfigDict(extra="forbid", frozen=True)


class Points(BaseValueModel):
    """
    Класс для представления количества очков.

    Attributes:
        value (int): Количество очков.
        point_type (Points_type_enum): Тип очков.

    Methods:
        adjust (int): Меняет количество очков на заданное значение.

    Returns:
        Points: Новый объект Points с измененным количеством очков.

    """

    value: Annotated[int, Field(strict=True, ge=-(2**31), le=2**31 - 1)]
    point_type: PointsTypeEnum

    def adjust(self, delta: int) -> "Points":
        """
        Меняет количество очков на заданное значение.

        Args:
            delta (int): Заданное изменение количества очков.

        Returns:
            Points: Новый объект Points с измененным количеством очков.

        """

        new_value = self.value + delta
        return Points(value=new_value, point_type=self.point_type)

    def is_positive(self) -> bool:
        """Семантика: value > 0?"""
        return self.value > 0

    # ... другие семантические методы
```

## Альтернативы

* **Продолжать использовать `int` (Primitive Obsession):**
  * *Плюсы:* Простота, отсутствие оверхеда на создание объектов.
  * *Минусы:* Нарушение принципа DRY (валидация везде), низкая связность кода, сложность поддержки при усложнении логики начисления баллов. [Ссылка на code smell](https://refactoring.guru/ru/smells/primitive-obsession)

* **Использовать мутабельные объекты:**
  * *Плюсы:* Экономия памяти (изменение in-place).
  * *Минусы:* Теряется идентичность Value Object (VO определяется значением, а не ссылкой). Усложняется отладка и тестирование (side effects), противоречит принятому курсу на иммутабельность (ADR 002).

* **Использовать стандартные `dataclasses`:**
  * *Плюсы:* Встроено в Python.
  * *Минусы:* Pydantic предоставляет более декларативную и строгую валидацию типов и диапазонов значений (Field constraints), что критично для VO, гарантирующего свою валидность.

## Последствия

### Положительные

* **Улучшенная валидация:** Невозможно создать объект `Points` с некорректным значением (например, выходящим за пределы integer). Если объект существует — он валиден.
* **Повышение читаемости:** Код становится самодокументируемым. Вызов `points.compare_to_threshold(100)` читается лучше, чем `points.value >= 100`.
* **DRY и Связность (Cohesion):** Логика изменения баллов находится в одном месте. Если правила изменения баллов поменяются, правки вносятся только в класс `Points`.
* **Тестируемость:** Класс `Points` можно покрыть unit-тестами изолированно от бизнес-логики сервисов. Сервисы, использующие `Points`, тестировать проще, так как поведение компонента очков предсказуемо.
* **Безопасность:** Иммутабельность предотвращает случайное изменение баланса пользователя по ссылке в недрах сложной логики.

### Отрицательные

* **Многословность (Verbosity):** Необходимо "разворачивать" примитивы в объекты. Сериализация в БД/JSON требует явного приведения типов (хотя Pydantic упрощает сериализацию в JSON).
* **Производительность:** Создание новых экземпляров объектов при каждой математической операции (в методе `adjust`) немного дороже простых арифметических операций с `int`. Однако в контексте бизнес-логики Telegram-бота это пренебрежимо мало по сравнению с I/O операциями (БД, сеть).

## Ссылки

* [Pydantic V2: Immutability and frozen models](https://docs.pydantic.dev/latest/api/config/#pydantic.config.ConfigDict.frozen)
* [Martin Fowler: ValueObject](https://martinfowler.com/bliki/ValueObject.html)
